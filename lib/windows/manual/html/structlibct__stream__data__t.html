<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Caretaker Library API 1.6.5 Reference Manual: libct_stream_data_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Caretaker Library API 1.6.5 Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">libct_stream_data_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This structure is used to hand-off data received from the remote device to the application.  
 <a href="structlibct__stream__data__t.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:aefc1c45b5428116d9687d04b5b0b1217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibct__device__t.html">libct_device_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#aefc1c45b5428116d9687d04b5b0b1217">device</a></td></tr>
<tr class="memdesc:aefc1c45b5428116d9687d04b5b0b1217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the device that generated this data.  <a href="#aefc1c45b5428116d9687d04b5b0b1217">More...</a><br /></td></tr>
<tr class="separator:aefc1c45b5428116d9687d04b5b0b1217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd435cfa122f7ec2ebd609ebc25551fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibct__device__status__t.html">libct_device_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#acd435cfa122f7ec2ebd609ebc25551fd">device_status</a></td></tr>
<tr class="memdesc:acd435cfa122f7ec2ebd609ebc25551fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device status information.  <a href="#acd435cfa122f7ec2ebd609ebc25551fd">More...</a><br /></td></tr>
<tr class="separator:acd435cfa122f7ec2ebd609ebc25551fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae093acee0cc5b3ea853292856a049adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibct__battery__info__t.html">libct_battery_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#ae093acee0cc5b3ea853292856a049adf">battery_info</a></td></tr>
<tr class="memdesc:ae093acee0cc5b3ea853292856a049adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Battery information.  <a href="#ae093acee0cc5b3ea853292856a049adf">More...</a><br /></td></tr>
<tr class="separator:ae093acee0cc5b3ea853292856a049adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc311a9f1b1b0c0fa767fbe2ebe9dd33"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a8759fa04d4cebc2eadbc011c8c734c6a"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__vitals__t.html">libct_vitals_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a9ce59773231a798baa0107f75ee51b7c">datapoints</a></td></tr>
<tr class="memdesc:a8759fa04d4cebc2eadbc011c8c734c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of vital sign datapoints.  <a href="#a8759fa04d4cebc2eadbc011c8c734c6a">More...</a><br /></td></tr>
<tr class="separator:a8759fa04d4cebc2eadbc011c8c734c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb6069e2de8361f65324a7ce2331fe2"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:adeb6069e2de8361f65324a7ce2331fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of datapoints.  <a href="#adeb6069e2de8361f65324a7ce2331fe2">More...</a><br /></td></tr>
<tr class="separator:adeb6069e2de8361f65324a7ce2331fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc311a9f1b1b0c0fa767fbe2ebe9dd33"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#afc311a9f1b1b0c0fa767fbe2ebe9dd33">vitals</a></td></tr>
<tr class="memdesc:afc311a9f1b1b0c0fa767fbe2ebe9dd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of vital sign data points.  <a href="#afc311a9f1b1b0c0fa767fbe2ebe9dd33">More...</a><br /></td></tr>
<tr class="separator:afc311a9f1b1b0c0fa767fbe2ebe9dd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1a133f4074ebb75d8e770bc81bcefa"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a55d8b23a1864d5351036dac01580407b"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__cuff__pressure__t.html">libct_cuff_pressure_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a91f24b4b0bf80fcf10e8810cedf63448">datapoints</a></td></tr>
<tr class="memdesc:a55d8b23a1864d5351036dac01580407b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of cuff pressure data points.  <a href="#a55d8b23a1864d5351036dac01580407b">More...</a><br /></td></tr>
<tr class="separator:a55d8b23a1864d5351036dac01580407b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7904fd5033f4a83fdd1ad0e0829f4a7"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:ab7904fd5033f4a83fdd1ad0e0829f4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of data points.  <a href="#ab7904fd5033f4a83fdd1ad0e0829f4a7">More...</a><br /></td></tr>
<tr class="separator:ab7904fd5033f4a83fdd1ad0e0829f4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1a133f4074ebb75d8e770bc81bcefa"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#a3b1a133f4074ebb75d8e770bc81bcefa">cuff_pressure</a></td></tr>
<tr class="memdesc:a3b1a133f4074ebb75d8e770bc81bcefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of cuff pressure data points.  <a href="#a3b1a133f4074ebb75d8e770bc81bcefa">More...</a><br /></td></tr>
<tr class="separator:a3b1a133f4074ebb75d8e770bc81bcefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d5c9b74674ca59033197296274b630"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a1fdb13fe59461ea36c2581cb4948ed16"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__temperature__t.html">libct_temperature_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a32f919494a6d166c672bd21792bd9c68">datapoints</a></td></tr>
<tr class="memdesc:a1fdb13fe59461ea36c2581cb4948ed16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of temperature data points.  <a href="#a1fdb13fe59461ea36c2581cb4948ed16">More...</a><br /></td></tr>
<tr class="separator:a1fdb13fe59461ea36c2581cb4948ed16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122af4e09f124a26c6c432f4136358fe"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:a122af4e09f124a26c6c432f4136358fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of data points.  <a href="#a122af4e09f124a26c6c432f4136358fe">More...</a><br /></td></tr>
<tr class="separator:a122af4e09f124a26c6c432f4136358fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d5c9b74674ca59033197296274b630"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#a52d5c9b74674ca59033197296274b630">temperature</a></td></tr>
<tr class="memdesc:a52d5c9b74674ca59033197296274b630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of temperature data points.  <a href="#a52d5c9b74674ca59033197296274b630">More...</a><br /></td></tr>
<tr class="separator:a52d5c9b74674ca59033197296274b630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079886687b58de45f7cac9d34171e09b"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a733664967dd77004b8f6518f33ac940f"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__pulse__ox__t.html">libct_pulse_ox_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a975ec90d9a1ba838b5ba094d7e6afc22">datapoints</a></td></tr>
<tr class="memdesc:a733664967dd77004b8f6518f33ac940f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of spo2 data points.  <a href="#a733664967dd77004b8f6518f33ac940f">More...</a><br /></td></tr>
<tr class="separator:a733664967dd77004b8f6518f33ac940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa2774112db458da95ff51637c35a9c"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:afaa2774112db458da95ff51637c35a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of data points.  <a href="#afaa2774112db458da95ff51637c35a9c">More...</a><br /></td></tr>
<tr class="separator:afaa2774112db458da95ff51637c35a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079886687b58de45f7cac9d34171e09b"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#a079886687b58de45f7cac9d34171e09b">pulse_ox</a></td></tr>
<tr class="memdesc:a079886687b58de45f7cac9d34171e09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of pulse oximetry data points.  <a href="#a079886687b58de45f7cac9d34171e09b">More...</a><br /></td></tr>
<tr class="separator:a079886687b58de45f7cac9d34171e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37923f7f37d12700dceafe6257bc0889"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a0d75a6c706cb0ab497b3a13edf24fa06"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__vitals2__t.html">libct_vitals2_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#aaa3f3c2917fb1b98dcb908117ff47761">datapoints</a></td></tr>
<tr class="memdesc:a0d75a6c706cb0ab497b3a13edf24fa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of secondary vital sign data points.  <a href="#a0d75a6c706cb0ab497b3a13edf24fa06">More...</a><br /></td></tr>
<tr class="separator:a0d75a6c706cb0ab497b3a13edf24fa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206453ae59a5b50b2cb86a710d49a873"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:a206453ae59a5b50b2cb86a710d49a873"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of data points.  <a href="#a206453ae59a5b50b2cb86a710d49a873">More...</a><br /></td></tr>
<tr class="separator:a206453ae59a5b50b2cb86a710d49a873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37923f7f37d12700dceafe6257bc0889"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#a37923f7f37d12700dceafe6257bc0889">vitals2</a></td></tr>
<tr class="memdesc:a37923f7f37d12700dceafe6257bc0889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of secondary vital sign data points.  <a href="#a37923f7f37d12700dceafe6257bc0889">More...</a><br /></td></tr>
<tr class="separator:a37923f7f37d12700dceafe6257bc0889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3589cd6c6b3d62e91bd1785abfc573e"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a2e8629da68669ce7db4736dfd00e4901"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__pulse__t.html">libct_pulse_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a583d3846b469131525e2fb1196b3fade">datapoints</a></td></tr>
<tr class="memdesc:a2e8629da68669ce7db4736dfd00e4901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of raw pulse (pulse rate) data points.  <a href="#a2e8629da68669ce7db4736dfd00e4901">More...</a><br /></td></tr>
<tr class="separator:a2e8629da68669ce7db4736dfd00e4901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588af8c1be1ae4931d546603bc4d075f"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:a588af8c1be1ae4931d546603bc4d075f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of data points.  <a href="#a588af8c1be1ae4931d546603bc4d075f">More...</a><br /></td></tr>
<tr class="separator:a588af8c1be1ae4931d546603bc4d075f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3589cd6c6b3d62e91bd1785abfc573e"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#ac3589cd6c6b3d62e91bd1785abfc573e">raw_pulse</a></td></tr>
<tr class="memdesc:ac3589cd6c6b3d62e91bd1785abfc573e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of raw pulse (pulse rate) waveform data points.  <a href="#ac3589cd6c6b3d62e91bd1785abfc573e">More...</a><br /></td></tr>
<tr class="separator:ac3589cd6c6b3d62e91bd1785abfc573e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5111bae79e796aa84abce5a69c5006c"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a88ec87179b7c8c2de6dd9b93f050df98"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__pulse__t.html">libct_pulse_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a583d3846b469131525e2fb1196b3fade">datapoints</a></td></tr>
<tr class="memdesc:a88ec87179b7c8c2de6dd9b93f050df98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of integrated pulse (pulse pressure) data points.  <a href="#a88ec87179b7c8c2de6dd9b93f050df98">More...</a><br /></td></tr>
<tr class="separator:a88ec87179b7c8c2de6dd9b93f050df98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fad1421d385c15d349c4ca28d31be2"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:af0fad1421d385c15d349c4ca28d31be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of data points.  <a href="#af0fad1421d385c15d349c4ca28d31be2">More...</a><br /></td></tr>
<tr class="separator:af0fad1421d385c15d349c4ca28d31be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5111bae79e796aa84abce5a69c5006c"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#ac5111bae79e796aa84abce5a69c5006c">int_pulse</a></td></tr>
<tr class="memdesc:ac5111bae79e796aa84abce5a69c5006c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of integrated pulse (pulse pressure) waveform data points.  <a href="#ac5111bae79e796aa84abce5a69c5006c">More...</a><br /></td></tr>
<tr class="separator:ac5111bae79e796aa84abce5a69c5006c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce0ff8999cc960569ba99b9517cb0e3"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a76b20572d519f23acd77794bf9c12b5e"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__param__pulse__t.html">libct_param_pulse_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a1d8e7cd3054ef32a129b07986b9504b0">datapoints</a></td></tr>
<tr class="memdesc:a76b20572d519f23acd77794bf9c12b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of parameterize pulse (pulse snapshot) data points.  <a href="#a76b20572d519f23acd77794bf9c12b5e">More...</a><br /></td></tr>
<tr class="separator:a76b20572d519f23acd77794bf9c12b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea302bb59f1c9804a0adb6e71be1261d"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:aea302bb59f1c9804a0adb6e71be1261d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of data points.  <a href="#aea302bb59f1c9804a0adb6e71be1261d">More...</a><br /></td></tr>
<tr class="separator:aea302bb59f1c9804a0adb6e71be1261d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce0ff8999cc960569ba99b9517cb0e3"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#adce0ff8999cc960569ba99b9517cb0e3">param_pulse</a></td></tr>
<tr class="memdesc:adce0ff8999cc960569ba99b9517cb0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of parameterized pulse data.  <a href="#adce0ff8999cc960569ba99b9517cb0e3">More...</a><br /></td></tr>
<tr class="separator:adce0ff8999cc960569ba99b9517cb0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207b3a789077b114492d7b16778e29f8"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a348f784ba3e1845fef092b9ec2955fa6"><td class="memItemLeft" >&#160;&#160;&#160;<a class="el" href="structlibct__cal__curve__t.html">libct_cal_curve_t</a> *&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a77cf2293ced0b68502607c4b8df8f60d">datapoints</a></td></tr>
<tr class="memdesc:a348f784ba3e1845fef092b9ec2955fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of calibration curve data points.  <a href="#a348f784ba3e1845fef092b9ec2955fa6">More...</a><br /></td></tr>
<tr class="separator:a348f784ba3e1845fef092b9ec2955fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0b32ab74f0e7014f286e11dbbcaaa2"><td class="memItemLeft" >&#160;&#160;&#160;unsigned int&#160;&#160;&#160;<a class="el" href="structlibct__stream__data__t.html#a5f833cceafa76e781f7a3bdebb7ebcc9">count</a></td></tr>
<tr class="memdesc:a9b0b32ab74f0e7014f286e11dbbcaaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The count of data points.  <a href="#a9b0b32ab74f0e7014f286e11dbbcaaa2">More...</a><br /></td></tr>
<tr class="separator:a9b0b32ab74f0e7014f286e11dbbcaaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207b3a789077b114492d7b16778e29f8"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#a207b3a789077b114492d7b16778e29f8">cal_curve</a></td></tr>
<tr class="memdesc:a207b3a789077b114492d7b16778e29f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of calibration curve data points.  <a href="#a207b3a789077b114492d7b16778e29f8">More...</a><br /></td></tr>
<tr class="separator:a207b3a789077b114492d7b16778e29f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed3b002d4c9c8baf6b51cc0396bbfc2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibct__stream__data__t.html#a4ed3b002d4c9c8baf6b51cc0396bbfc2">receive_time</a></td></tr>
<tr class="memdesc:a4ed3b002d4c9c8baf6b51cc0396bbfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of local clock (in milliseconds) when this stream packet was received.  <a href="#a4ed3b002d4c9c8baf6b51cc0396bbfc2">More...</a><br /></td></tr>
<tr class="separator:a4ed3b002d4c9c8baf6b51cc0396bbfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This structure is used to hand-off data received from the remote device to the application. </p>
<p>Data from the device is sent automatically after calling <a class="el" href="group__unmanaged__primary__api.html#gacd0089083e2cc42c2b85c5b9ed382610" title="Start monitoring data at the remote caretaker device. ">libct_start_monitoring()</a> successfully, and delivered to your application via the <a class="el" href="structlibct__app__callbacks__t.html#ad39120a47c368701668fffed0d3f9c55">on_data_received()</a> callback function. This data structure is a container of arrays grouping one or more records of the same data type at different time instances. The various array data types are not produced coherently at the device so not all fields will be populated in stream data packets delivered to the application. If no data is available for a given array, the array data points field will be set to null and the count set to zero to signal no data.</p>
<p>The stream data packets notified to the application depends on the <a class="el" href="classlibct__monitor__flags__t.html">monitor flags</a> passed to <a class="el" href="group__unmanaged__primary__api.html#gacd0089083e2cc42c2b85c5b9ed382610" title="Start monitoring data at the remote caretaker device. ">libct_start_monitoring()</a> and whether or not <a class="el" href="group__unmanaged__primary__api.html#ga0443e1faf46f302d85a920e790df3601" title="Start taking measurement. ">libct_start_measuring()</a> was called to start taking vital sign measurements. So you can control the data reported to the application by specifying only the monitoring flags corresponding to the data you care about.</p>
<p>With the exception of the <a class="el" href="structlibct__stream__data__t.html#acd435cfa122f7ec2ebd609ebc25551fd">device_status</a> and <a class="el" href="structlibct__stream__data__t.html#ae093acee0cc5b3ea853292856a049adf">battery_info</a> data members that are not array fields, the following convenience macros are available to access array entries within the stream data packet. More details about usage is provided in the description for each stream data member where the macros apply. </p><ul>
<li>
<a class="el" href="group__unmanaged__secondary__api.html#ga2d094ef0a99f1b0fcb7393c90086099a" title="Returns the count of data points of the specified member array contained in stream data received at t...">libct_dp_count()</a> </li>
<li>
<a class="el" href="group__unmanaged__secondary__api.html#gad9427f299d6cd42e8ea987576c698cef" title="Extract a single data point from the specified member array contained in stream data received at the ...">libct_get_dp()</a> </li>
<li>
<a class="el" href="group__unmanaged__secondary__api.html#ga5728fbb6b32827a9ca873d6e422d540b" title="Extract the oldest data point from the specified member array contained in stream data received at th...">libct_get_first_dp()</a> </li>
<li>
<a class="el" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf" title="Extract the newest data point from the specified member array contained in stream data received at th...">libct_get_last_dp()</a> </li>
<li>
<a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> </li>
</ul>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="aefc1c45b5428116d9687d04b5b0b1217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc1c45b5428116d9687d04b5b0b1217">&#9670;&nbsp;</a></span>device</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__device__t.html">libct_device_t</a>* libct_stream_data_t::device</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to the device that generated this data. </p>

</div>
</div>
<a id="acd435cfa122f7ec2ebd609ebc25551fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd435cfa122f7ec2ebd609ebc25551fd">&#9670;&nbsp;</a></span>device_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__device__status__t.html">libct_device_status_t</a> libct_stream_data_t::device_status</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device status information. </p>

</div>
</div>
<a id="ae093acee0cc5b3ea853292856a049adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae093acee0cc5b3ea853292856a049adf">&#9670;&nbsp;</a></span>battery_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__battery__info__t.html">libct_battery_info_t</a> libct_stream_data_t::battery_info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Battery information. </p>

</div>
</div>
<a id="a9ce59773231a798baa0107f75ee51b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce59773231a798baa0107f75ee51b7c">&#9670;&nbsp;</a></span>datapoints <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__vitals__t.html">libct_vitals_t</a>* libct_stream_data_t::datapoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of vital sign datapoints. </p>

</div>
</div>
<a id="a5f833cceafa76e781f7a3bdebb7ebcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f833cceafa76e781f7a3bdebb7ebcc9">&#9670;&nbsp;</a></span>count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libct_stream_data_t::count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The count of datapoints. </p>
<p>The count of data points.</p>

</div>
</div>
<a id="afc311a9f1b1b0c0fa767fbe2ebe9dd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc311a9f1b1b0c0fa767fbe2ebe9dd33">&#9670;&nbsp;</a></span>vitals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::vitals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of vital sign data points. </p>
<p>For convenience, you can use the macros <a class="el" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf" title="Extract the newest data point from the specified member array contained in stream data received at th...">libct_get_last_dp()</a>, <a class="el" href="group__unmanaged__secondary__api.html#ga5728fbb6b32827a9ca873d6e422d540b" title="Extract the oldest data point from the specified member array contained in stream data received at th...">libct_get_first_dp()</a>, and <a class="el" href="group__unmanaged__secondary__api.html#gad9427f299d6cd42e8ea987576c698cef" title="Extract a single data point from the specified member array contained in stream data received at the ...">libct_get_dp()</a> to extract a single vital sign data point from the stream packet like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__vitals__t.html">libct_vitals_t</a>* dp = <a class="code" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf">libct_get_last_dp</a>(data, <a class="code" href="structlibct__stream__data__t.html#afc311a9f1b1b0c0fa767fbe2ebe9dd33">vitals</a>);</div><div class="line"><span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__vitals__t.html#ae08a12a345564a509ad8629a626f88b4">valid</a> ) {</div><div class="line">    <span class="comment">// use most recent vitals data point</span></div><div class="line">}</div></div><!-- fragment --> <p>Alternatively, you could iterate over all vital sign data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__vitals__t.html">libct_vitals_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, <a class="code" href="structlibct__stream__data__t.html#afc311a9f1b1b0c0fa767fbe2ebe9dd33">vitals</a>) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__vitals__t.html#ae08a12a345564a509ad8629a626f88b4">valid</a> ) {</div><div class="line">        <span class="comment">// use vitals data point</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a91f24b4b0bf80fcf10e8810cedf63448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f24b4b0bf80fcf10e8810cedf63448">&#9670;&nbsp;</a></span>datapoints <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__cuff__pressure__t.html">libct_cuff_pressure_t</a>* libct_stream_data_t::datapoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of cuff pressure data points. </p>

</div>
</div>
<a id="a3b1a133f4074ebb75d8e770bc81bcefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1a133f4074ebb75d8e770bc81bcefa">&#9670;&nbsp;</a></span>cuff_pressure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::cuff_pressure</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of cuff pressure data points. </p>
<p>For convenience, you can use the macros <a class="el" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf" title="Extract the newest data point from the specified member array contained in stream data received at th...">libct_get_last_dp()</a>, <a class="el" href="group__unmanaged__secondary__api.html#ga5728fbb6b32827a9ca873d6e422d540b" title="Extract the oldest data point from the specified member array contained in stream data received at th...">libct_get_first_dp()</a>, and <a class="el" href="group__unmanaged__secondary__api.html#gad9427f299d6cd42e8ea987576c698cef" title="Extract a single data point from the specified member array contained in stream data received at the ...">libct_get_dp()</a> to extract a single cuff pressure data point from the stream packet like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__cuff__pressure__t.html">libct_cuff_pressure_t</a>* dp = <a class="code" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf">libct_get_last_dp</a>(data, <a class="code" href="structlibct__stream__data__t.html#a3b1a133f4074ebb75d8e770bc81bcefa">cuff_pressure</a>);</div><div class="line"><span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__cuff__pressure__t.html#ae8bd13e2694766aef11148b94ebc4a18">valid</a> ) {</div><div class="line">    <span class="comment">// use most recent cuff pressure data point</span></div><div class="line">}</div></div><!-- fragment --> <p>Alternatively, you could iterate over all cuff pressure data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__cuff__pressure__t.html">libct_cuff_pressure_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, <a class="code" href="structlibct__stream__data__t.html#a3b1a133f4074ebb75d8e770bc81bcefa">cuff_pressure</a>) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__cuff__pressure__t.html#ae8bd13e2694766aef11148b94ebc4a18">valid</a> ) {</div><div class="line">        <span class="comment">// use cuff pressure data point</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a32f919494a6d166c672bd21792bd9c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f919494a6d166c672bd21792bd9c68">&#9670;&nbsp;</a></span>datapoints <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__temperature__t.html">libct_temperature_t</a>* libct_stream_data_t::datapoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of temperature data points. </p>

</div>
</div>
<a id="a52d5c9b74674ca59033197296274b630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d5c9b74674ca59033197296274b630">&#9670;&nbsp;</a></span>temperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::temperature</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of temperature data points. </p>
<p>For convenience, you can use the macros <a class="el" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf" title="Extract the newest data point from the specified member array contained in stream data received at th...">libct_get_last_dp()</a>, <a class="el" href="group__unmanaged__secondary__api.html#ga5728fbb6b32827a9ca873d6e422d540b" title="Extract the oldest data point from the specified member array contained in stream data received at th...">libct_get_first_dp()</a>, and <a class="el" href="group__unmanaged__secondary__api.html#gad9427f299d6cd42e8ea987576c698cef" title="Extract a single data point from the specified member array contained in stream data received at the ...">libct_get_dp()</a> to extract a single temperature data point from the stream packet like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__temperature__t.html">libct_temperature_t</a>* dp = <a class="code" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf">libct_get_last_dp</a>(data, <a class="code" href="structlibct__stream__data__t.html#a52d5c9b74674ca59033197296274b630">temperature</a>);</div><div class="line"><span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__temperature__t.html#aeb6bf80be176794c4ea669fa60a9c39b">valid</a> ) {</div><div class="line">    <span class="comment">// use most recent temperature data point</span></div><div class="line">}</div></div><!-- fragment --> <p>Alternatively, you could iterate over all temperature data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__temperature__t.html">libct_temperature_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, <a class="code" href="structlibct__stream__data__t.html#a52d5c9b74674ca59033197296274b630">temperature</a>) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__temperature__t.html#aeb6bf80be176794c4ea669fa60a9c39b">valid</a> ) {</div><div class="line">        <span class="comment">// use temperature data point</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a975ec90d9a1ba838b5ba094d7e6afc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975ec90d9a1ba838b5ba094d7e6afc22">&#9670;&nbsp;</a></span>datapoints <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__pulse__ox__t.html">libct_pulse_ox_t</a>* libct_stream_data_t::datapoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of spo2 data points. </p>

</div>
</div>
<a id="a079886687b58de45f7cac9d34171e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079886687b58de45f7cac9d34171e09b">&#9670;&nbsp;</a></span>pulse_ox</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::pulse_ox</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of pulse oximetry data points. </p>
<p>For convenience, you can use the macros <a class="el" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf" title="Extract the newest data point from the specified member array contained in stream data received at th...">libct_get_last_dp()</a>, <a class="el" href="group__unmanaged__secondary__api.html#ga5728fbb6b32827a9ca873d6e422d540b" title="Extract the oldest data point from the specified member array contained in stream data received at th...">libct_get_first_dp()</a>, and <a class="el" href="group__unmanaged__secondary__api.html#gad9427f299d6cd42e8ea987576c698cef" title="Extract a single data point from the specified member array contained in stream data received at the ...">libct_get_dp()</a> to extract a single spo2 data point from the stream packet like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__pulse__ox__t.html">libct_pulse_ox_t</a>* dp = <a class="code" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf">libct_get_last_dp</a>(data, <a class="code" href="structlibct__stream__data__t.html#a079886687b58de45f7cac9d34171e09b">pulse_ox</a>);</div><div class="line"><span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__pulse__ox__t.html#a7541021ac2268f64c95b6485d227980a">valid</a> ) {</div><div class="line">    <span class="comment">// use most recent spo2 data point</span></div><div class="line">}</div></div><!-- fragment --> <p>Alternatively, you could iterate over all spo2 data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__pulse__ox__t.html">libct_pulse_ox_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, <a class="code" href="structlibct__stream__data__t.html#a079886687b58de45f7cac9d34171e09b">pulse_ox</a>) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__pulse__ox__t.html#a7541021ac2268f64c95b6485d227980a">valid</a> ) {</div><div class="line">        <span class="comment">// use spo2 data point</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="aaa3f3c2917fb1b98dcb908117ff47761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3f3c2917fb1b98dcb908117ff47761">&#9670;&nbsp;</a></span>datapoints <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__vitals2__t.html">libct_vitals2_t</a>* libct_stream_data_t::datapoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of secondary vital sign data points. </p>

</div>
</div>
<a id="a37923f7f37d12700dceafe6257bc0889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37923f7f37d12700dceafe6257bc0889">&#9670;&nbsp;</a></span>vitals2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::vitals2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of secondary vital sign data points. </p>
<dl class="section note"><dt>Note</dt><dd>The secondary vitals are for internal use or research only. </dd></dl>
<p>For convenience, you can use the macros <a class="el" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf" title="Extract the newest data point from the specified member array contained in stream data received at th...">libct_get_last_dp()</a>, <a class="el" href="group__unmanaged__secondary__api.html#ga5728fbb6b32827a9ca873d6e422d540b" title="Extract the oldest data point from the specified member array contained in stream data received at th...">libct_get_first_dp()</a>, and <a class="el" href="group__unmanaged__secondary__api.html#gad9427f299d6cd42e8ea987576c698cef" title="Extract a single data point from the specified member array contained in stream data received at the ...">libct_get_dp()</a> to extract a single secondary vital sign data point from the stream packet. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__vitals2__t.html">libct_vitals2_t</a>* dp = <a class="code" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf">libct_get_last_dp</a>(data, <a class="code" href="structlibct__stream__data__t.html#a37923f7f37d12700dceafe6257bc0889">vitals2</a>);</div><div class="line"><span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__vitals2__t.html#aca5c56474f5af19e8b1aeaf7a6c45af8">valid</a> ) {</div><div class="line">    <span class="comment">// use most recent secondary vitals data point</span></div><div class="line">}</div></div><!-- fragment --> <p>Alternatively, you could iterate over all secondary vital sign data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__vitals2__t.html">libct_vitals2_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, <a class="code" href="structlibct__stream__data__t.html#afc311a9f1b1b0c0fa767fbe2ebe9dd33">vitals</a>) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__vitals2__t.html#aca5c56474f5af19e8b1aeaf7a6c45af8">valid</a> ) {</div><div class="line">        <span class="comment">// use secondary vitals data point</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a583d3846b469131525e2fb1196b3fade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583d3846b469131525e2fb1196b3fade">&#9670;&nbsp;</a></span>datapoints <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__pulse__t.html">libct_pulse_t</a>* libct_stream_data_t::datapoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of raw pulse (pulse rate) data points. </p>
<p>Array of integrated pulse (pulse pressure) data points.</p>

</div>
</div>
<a id="ac3589cd6c6b3d62e91bd1785abfc573e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3589cd6c6b3d62e91bd1785abfc573e">&#9670;&nbsp;</a></span>raw_pulse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::raw_pulse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of raw pulse (pulse rate) waveform data points. </p>
<p>For convenience, you could iterate over all raw pulse data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__pulse__t.html">libct_pulse_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, <a class="code" href="structlibct__stream__data__t.html#ac3589cd6c6b3d62e91bd1785abfc573e">raw_pulse</a>) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__pulse__t.html#a0556fc1459a5e4bae8a8154cf770e736">valid</a> ) {</div><div class="line">        <span class="comment">// use pulse data point</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ac5111bae79e796aa84abce5a69c5006c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5111bae79e796aa84abce5a69c5006c">&#9670;&nbsp;</a></span>int_pulse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::int_pulse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of integrated pulse (pulse pressure) waveform data points. </p>
<p>For convenience, you could iterate over all integrated pulse data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__pulse__t.html">libct_pulse_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, <a class="code" href="structlibct__stream__data__t.html#ac5111bae79e796aa84abce5a69c5006c">int_pulse</a>) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__pulse__t.html#a0556fc1459a5e4bae8a8154cf770e736">valid</a> ) {</div><div class="line">        <span class="comment">// use pulse data point</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a1d8e7cd3054ef32a129b07986b9504b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8e7cd3054ef32a129b07986b9504b0">&#9670;&nbsp;</a></span>datapoints <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__param__pulse__t.html">libct_param_pulse_t</a>* libct_stream_data_t::datapoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of parameterize pulse (pulse snapshot) data points. </p>

</div>
</div>
<a id="adce0ff8999cc960569ba99b9517cb0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce0ff8999cc960569ba99b9517cb0e3">&#9670;&nbsp;</a></span>param_pulse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::param_pulse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of parameterized pulse data. </p>
<p>The data is an aggregate of the pulse parameters and pulse snapshot waveform data. </p>
<p>For convenience, you can use the macros <a class="el" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf" title="Extract the newest data point from the specified member array contained in stream data received at th...">libct_get_last_dp()</a>, <a class="el" href="group__unmanaged__secondary__api.html#ga5728fbb6b32827a9ca873d6e422d540b" title="Extract the oldest data point from the specified member array contained in stream data received at th...">libct_get_first_dp()</a>, and <a class="el" href="group__unmanaged__secondary__api.html#gad9427f299d6cd42e8ea987576c698cef" title="Extract a single data point from the specified member array contained in stream data received at the ...">libct_get_dp()</a> to extract a single pulse snapshot from the stream packet like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__param__pulse__t.html">libct_param_pulse_t</a>* dp = <a class="code" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf">libct_get_last_dp</a>(data, <a class="code" href="structlibct__stream__data__t.html#adce0ff8999cc960569ba99b9517cb0e3">param_pulse</a>);</div><div class="line"><span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__param__pulse__t.html#a97b4a5f5527094823167fccd8fba2722">valid</a> ) {</div><div class="line">    <span class="comment">// use most recent pulse snapshot</span></div><div class="line">}</div></div><!-- fragment --> <p>Alternatively, you could iterate over all pulse snapshot data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__param__pulse__t.html">libct_param_pulse_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, pulse_param) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__param__pulse__t.html#a97b4a5f5527094823167fccd8fba2722">valid</a> ) {</div><div class="line">        <span class="comment">// use pulse snapshot</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a77cf2293ced0b68502607c4b8df8f60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cf2293ced0b68502607c4b8df8f60d">&#9670;&nbsp;</a></span>datapoints <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibct__cal__curve__t.html">libct_cal_curve_t</a>* libct_stream_data_t::datapoints</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of calibration curve data points. </p>

</div>
</div>
<a id="a207b3a789077b114492d7b16778e29f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207b3a789077b114492d7b16778e29f8">&#9670;&nbsp;</a></span>cal_curve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   libct_stream_data_t::cal_curve</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of calibration curve data points. </p>
<dl class="section note"><dt>Note</dt><dd>The cal curve data is for internal use or research only </dd></dl>
<p>For convenience, you can use the macros <a class="el" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf" title="Extract the newest data point from the specified member array contained in stream data received at th...">libct_get_last_dp()</a>, <a class="el" href="group__unmanaged__secondary__api.html#ga5728fbb6b32827a9ca873d6e422d540b" title="Extract the oldest data point from the specified member array contained in stream data received at th...">libct_get_first_dp()</a>, and <a class="el" href="group__unmanaged__secondary__api.html#gad9427f299d6cd42e8ea987576c698cef" title="Extract a single data point from the specified member array contained in stream data received at the ...">libct_get_dp()</a> to extract a single calibration curve data point from the stream packet like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__cal__curve__t.html">libct_cal_curve_t</a>* dp = <a class="code" href="group__unmanaged__secondary__api.html#gae1343df5cd2d51b866df8b19690e27cf">libct_get_last_dp</a>(data, <a class="code" href="structlibct__stream__data__t.html#a207b3a789077b114492d7b16778e29f8">cal_curve</a>);</div><div class="line"><span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__cal__curve__t.html#a26d1c102e4813c7a4db146218302a62d">valid</a> ) {</div><div class="line">    <span class="comment">// use most recent calibration curve data point</span></div><div class="line">}</div></div><!-- fragment --> <p>Alternatively, you could iterate over all calibration curve data points with the <a class="el" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e" title="Iterate over data points of the specified member array to extract from stream data received at the ap...">for_each_dp()</a> macro like so. </p><div class="fragment"><div class="line"><a class="code" href="structlibct__cal__curve__t.html">libct_cal_curve_t</a>* dp;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;</div><div class="line"><a class="code" href="group__unmanaged__secondary__api.html#gaf96aa5c908424aaab9ae11aabc0c7c8e">for_each_dp</a>(data, idx, dp, <a class="code" href="structlibct__stream__data__t.html#a207b3a789077b114492d7b16778e29f8">cal_curve</a>) {</div><div class="line">    <span class="keywordflow">if</span> ( dp &amp;&amp; dp-&gt;<a class="code" href="structlibct__cal__curve__t.html#a26d1c102e4813c7a4db146218302a62d">valid</a> ) {</div><div class="line">        <span class="comment">// use calibration curve data point</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a4ed3b002d4c9c8baf6b51cc0396bbfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed3b002d4c9c8baf6b51cc0396bbfc2">&#9670;&nbsp;</a></span>receive_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long libct_stream_data_t::receive_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of local clock (in milliseconds) when this stream packet was received. </p>
<p>This time stamp is used to measure processing latency and for history logging. It differs from time stamp found in each data point generated by the remote device. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="caretaker_8h_source.html">caretaker.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 11 2018 10:47:19 for Caretaker Library API 1.6.5 Reference Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
