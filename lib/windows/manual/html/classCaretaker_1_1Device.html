<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Caretaker Library API 1.6.5 Reference Manual: Caretaker::Device Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Caretaker Library API 1.6.5 Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Caretaker</b></li><li class="navelem"><a class="el" href="classCaretaker_1_1Device.html">Device</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Caretaker::Device Class Reference<div class="ingroups"><a class="el" href="group__windows__managed__api.html">Managed API for .NET Applications</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Managed class for .NET applications to monitor the Caretaker device.  
 <a href="classCaretaker_1_1Device.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device_1_1LibraryCallback.html">LibraryCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal class representing a callback into the unmanaged library code.  <a href="classCaretaker_1_1Device_1_1LibraryCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f988cc0af06179d790bc7e4363c70e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a2f988cc0af06179d790bc7e4363c70e5">Device</a> (<a class="el" href="classCaretaker_1_1DeviceObserver.html">DeviceObserver</a>^ observer, Boolean autoReconnect)</td></tr>
<tr class="memdesc:a2f988cc0af06179d790bc7e4363c70e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classCaretaker_1_1Device.html" title="Managed class for .NET applications to monitor the Caretaker device. ">Device</a> instance.  <a href="#a2f988cc0af06179d790bc7e4363c70e5">More...</a><br /></td></tr>
<tr class="separator:a2f988cc0af06179d790bc7e4363c70e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af070b8fa2467f159f0eb527d553ff9e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#af070b8fa2467f159f0eb527d553ff9e4">~Device</a> ()</td></tr>
<tr class="memdesc:af070b8fa2467f159f0eb527d553ff9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af070b8fa2467f159f0eb527d553ff9e4">More...</a><br /></td></tr>
<tr class="separator:af070b8fa2467f159f0eb527d553ff9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32373956203d4dd418477d8cd55b8f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7">ReleaseResources</a> ()</td></tr>
<tr class="memdesc:aa32373956203d4dd418477d8cd55b8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release unmanaged library resources allocated for the <a class="el" href="classCaretaker_1_1Device.html" title="Managed class for .NET applications to monitor the Caretaker device. ">Device</a> instance.  <a href="#aa32373956203d4dd418477d8cd55b8f7">More...</a><br /></td></tr>
<tr class="separator:aa32373956203d4dd418477d8cd55b8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23dc37a0ef2ac55ca77cd913663e18fa"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a23dc37a0ef2ac55ca77cd913663e18fa">StartScan</a> (UInt32 timeout)</td></tr>
<tr class="memdesc:a23dc37a0ef2ac55ca77cd913663e18fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates scanning for nearby Caretaker devices.  <a href="#a23dc37a0ef2ac55ca77cd913663e18fa">More...</a><br /></td></tr>
<tr class="separator:a23dc37a0ef2ac55ca77cd913663e18fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311b57f8ce95a1db0e86d726fe053c6d"><td class="memItemLeft" align="right" valign="top"><a id="a311b57f8ce95a1db0e86d726fe053c6d"></a>
Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a311b57f8ce95a1db0e86d726fe053c6d">StopScan</a> ()</td></tr>
<tr class="memdesc:a311b57f8ce95a1db0e86d726fe053c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to stop scanning after calling <a class="el" href="classCaretaker_1_1Device.html#a23dc37a0ef2ac55ca77cd913663e18fa" title="Initiates scanning for nearby Caretaker devices. ">StartScan()</a>. <br /></td></tr>
<tr class="separator:a311b57f8ce95a1db0e86d726fe053c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a541e1094860510352d6c1443be89d5"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a7a541e1094860510352d6c1443be89d5">ConnectToSerialNumber</a> (String^ sn, UInt32 timeout)</td></tr>
<tr class="memdesc:a7a541e1094860510352d6c1443be89d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates connecting to the Caretaker device with the specified serial number.  <a href="#a7a541e1094860510352d6c1443be89d5">More...</a><br /></td></tr>
<tr class="separator:a7a541e1094860510352d6c1443be89d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e7e189884e2fbcfea61559fc54f583"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#ad6e7e189884e2fbcfea61559fc54f583">ConnectToMacAddress</a> (String^ address, UInt32 timeout)</td></tr>
<tr class="memdesc:ad6e7e189884e2fbcfea61559fc54f583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates connecting to the Caretaker device with the specified MAC address.  <a href="#ad6e7e189884e2fbcfea61559fc54f583">More...</a><br /></td></tr>
<tr class="separator:ad6e7e189884e2fbcfea61559fc54f583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afc0dabbaf6cac1e91256af4b53c02e"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a4afc0dabbaf6cac1e91256af4b53c02e">ConnectToAny</a> (UInt32 timeout)</td></tr>
<tr class="memdesc:a4afc0dabbaf6cac1e91256af4b53c02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates connecting to any Caretaker device that is advertising for a connection.  <a href="#a4afc0dabbaf6cac1e91256af4b53c02e">More...</a><br /></td></tr>
<tr class="separator:a4afc0dabbaf6cac1e91256af4b53c02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245cb442071bbac2a9abe4c46aa5ac69"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a245cb442071bbac2a9abe4c46aa5ac69">Disconnect</a> ()</td></tr>
<tr class="memdesc:a245cb442071bbac2a9abe4c46aa5ac69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates disconnecting from the remote device if connected.  <a href="#a245cb442071bbac2a9abe4c46aa5ac69">More...</a><br /></td></tr>
<tr class="separator:a245cb442071bbac2a9abe4c46aa5ac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6adb913de3660f2665e3286192d091c"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#af6adb913de3660f2665e3286192d091c">StartAutoCal</a> (<a class="el" href="group__windows__managed__api.html#gabc29121ccac1aa1261962767a550112b">PatientPosture</a> posture)</td></tr>
<tr class="memdesc:af6adb913de3660f2665e3286192d091c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an automatic calibration and then start taking measurements if connected.  <a href="#af6adb913de3660f2665e3286192d091c">More...</a><br /></td></tr>
<tr class="separator:af6adb913de3660f2665e3286192d091c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbc203a2dae908d791241588e3c810a"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#aacbc203a2dae908d791241588e3c810a">StartManualCal</a> (Int32 systolic, Int32 diastolic)</td></tr>
<tr class="memdesc:aacbc203a2dae908d791241588e3c810a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a manual calibration and then start taking measurements if connected.  <a href="#aacbc203a2dae908d791241588e3c810a">More...</a><br /></td></tr>
<tr class="separator:aacbc203a2dae908d791241588e3c810a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e993b04a8cb5d4486843124679c049"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a50e993b04a8cb5d4486843124679c049">Stop</a> ()</td></tr>
<tr class="memdesc:a50e993b04a8cb5d4486843124679c049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method after calling <a class="el" href="classCaretaker_1_1Device.html#af6adb913de3660f2665e3286192d091c" title="Perform an automatic calibration and then start taking measurements if connected. ...">StartAutoCal()</a> or <a class="el" href="classCaretaker_1_1Device.html#aacbc203a2dae908d791241588e3c810a" title="Perform a manual calibration and then start taking measurements if connected. ">StartManualCal()</a> to stop the device.  <a href="#a50e993b04a8cb5d4486843124679c049">More...</a><br /></td></tr>
<tr class="separator:a50e993b04a8cb5d4486843124679c049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17b7ad9f426c46336c20b9c1868e45"><td class="memItemLeft" align="right" valign="top"><a id="a5e17b7ad9f426c46336c20b9c1868e45"></a>
Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a5e17b7ad9f426c46336c20b9c1868e45">IsConnected</a> ()</td></tr>
<tr class="memdesc:a5e17b7ad9f426c46336c20b9c1868e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is connected and false otherwise. <br /></td></tr>
<tr class="separator:a5e17b7ad9f426c46336c20b9c1868e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18785c46e934daf93fdcdeb7bca67163"><td class="memItemLeft" align="right" valign="top"><a id="a18785c46e934daf93fdcdeb7bca67163"></a>
Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a18785c46e934daf93fdcdeb7bca67163">IsConnecting</a> ()</td></tr>
<tr class="memdesc:a18785c46e934daf93fdcdeb7bca67163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true while attempting to establish connection to device and false otherwise. <br /></td></tr>
<tr class="separator:a18785c46e934daf93fdcdeb7bca67163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1082a83246988bd7de09f930cbf541"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#aca1082a83246988bd7de09f930cbf541">Calibrating</a> ()</td></tr>
<tr class="memdesc:aca1082a83246988bd7de09f930cbf541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is calibrating, and false otherwise.  <a href="#aca1082a83246988bd7de09f930cbf541">More...</a><br /></td></tr>
<tr class="separator:aca1082a83246988bd7de09f930cbf541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d8d3fe5a08b656780f42540eb2e318"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a47d8d3fe5a08b656780f42540eb2e318">Calibrated</a> ()</td></tr>
<tr class="memdesc:a47d8d3fe5a08b656780f42540eb2e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is calibrated, and false otherwise.  <a href="#a47d8d3fe5a08b656780f42540eb2e318">More...</a><br /></td></tr>
<tr class="separator:a47d8d3fe5a08b656780f42540eb2e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3eca610dc4bbca4b9eaf45d9c1e275d"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#af3eca610dc4bbca4b9eaf45d9c1e275d">CalibrationFailed</a> ()</td></tr>
<tr class="memdesc:af3eca610dc4bbca4b9eaf45d9c1e275d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device was calibrating and the calibration failed, and false otherwise.  <a href="#af3eca610dc4bbca4b9eaf45d9c1e275d">More...</a><br /></td></tr>
<tr class="separator:af3eca610dc4bbca4b9eaf45d9c1e275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6485652d4602825c0ded98914d0d464f"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a6485652d4602825c0ded98914d0d464f">GetName</a> ()</td></tr>
<tr class="memdesc:a6485652d4602825c0ded98914d0d464f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device friendly name or null if the name is not available.  <a href="#a6485652d4602825c0ded98914d0d464f">More...</a><br /></td></tr>
<tr class="separator:a6485652d4602825c0ded98914d0d464f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3a678b6819ca0f8dcacf9da56b63fa"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a8a3a678b6819ca0f8dcacf9da56b63fa">GetMacAddress</a> ()</td></tr>
<tr class="memdesc:a8a3a678b6819ca0f8dcacf9da56b63fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device MAC address or null if the MAC address is not available.  <a href="#a8a3a678b6819ca0f8dcacf9da56b63fa">More...</a><br /></td></tr>
<tr class="separator:a8a3a678b6819ca0f8dcacf9da56b63fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ad4e9da3fd413eab59019eebda4909"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#ae8ad4e9da3fd413eab59019eebda4909">GetSerialNumber</a> ()</td></tr>
<tr class="memdesc:ae8ad4e9da3fd413eab59019eebda4909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device serial number or null if the serial number is not available.  <a href="#ae8ad4e9da3fd413eab59019eebda4909">More...</a><br /></td></tr>
<tr class="separator:ae8ad4e9da3fd413eab59019eebda4909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7394f2c403b504aa23dc67324a3ef2d"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#af7394f2c403b504aa23dc67324a3ef2d">GetFirmwareVersion</a> ()</td></tr>
<tr class="memdesc:af7394f2c403b504aa23dc67324a3ef2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device firmware version or null if the firmware version is not available.  <a href="#af7394f2c403b504aa23dc67324a3ef2d">More...</a><br /></td></tr>
<tr class="separator:af7394f2c403b504aa23dc67324a3ef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a08418ed245269af880bf8a08a89083"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a2a08418ed245269af880bf8a08a89083">GetHardwareVersion</a> ()</td></tr>
<tr class="memdesc:a2a08418ed245269af880bf8a08a89083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device hardware version or null if the hardware version is not available.  <a href="#a2a08418ed245269af880bf8a08a89083">More...</a><br /></td></tr>
<tr class="separator:a2a08418ed245269af880bf8a08a89083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0a52390ae1b51b14973b4d9f15902f"><td class="memItemLeft" align="right" valign="top"><a id="aeb0a52390ae1b51b14973b4d9f15902f"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#aeb0a52390ae1b51b14973b4d9f15902f">GetLibraryVersion</a> ()</td></tr>
<tr class="memdesc:aeb0a52390ae1b51b14973b4d9f15902f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the library version or null if the library version is not available. <br /></td></tr>
<tr class="separator:aeb0a52390ae1b51b14973b4d9f15902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f79d3b3c577fb07c2f0b0b82158ed2"><td class="memItemLeft" align="right" valign="top"><a id="a36f79d3b3c577fb07c2f0b0b82158ed2"></a>
String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a36f79d3b3c577fb07c2f0b0b82158ed2">GetLibraryBuildDate</a> ()</td></tr>
<tr class="memdesc:a36f79d3b3c577fb07c2f0b0b82158ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the library build date or null if the build date is not available. <br /></td></tr>
<tr class="separator:a36f79d3b3c577fb07c2f0b0b82158ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b560a668cc920d21e0fd0563ed0273c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCaretaker_1_1DeviceStatus.html">DeviceStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a4b560a668cc920d21e0fd0563ed0273c">GetDeviceStatus</a> ()</td></tr>
<tr class="memdesc:a4b560a668cc920d21e0fd0563ed0273c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to poll device status.  <a href="#a4b560a668cc920d21e0fd0563ed0273c">More...</a><br /></td></tr>
<tr class="separator:a4b560a668cc920d21e0fd0563ed0273c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b9e8e39d130935edb278b6f3a2e8ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCaretaker_1_1BatteryStatus.html">BatteryStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a34b9e8e39d130935edb278b6f3a2e8ad">GetBatteryStatus</a> ()</td></tr>
<tr class="memdesc:a34b9e8e39d130935edb278b6f3a2e8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to poll battery status.  <a href="#a34b9e8e39d130935edb278b6f3a2e8ad">More...</a><br /></td></tr>
<tr class="separator:a34b9e8e39d130935edb278b6f3a2e8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e76258cd67c9bb27b2b95066185d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCaretaker_1_1CuffStatus.html">CuffStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f">GetCuffStatus</a> ()</td></tr>
<tr class="memdesc:a59e76258cd67c9bb27b2b95066185d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to poll cuff status.  <a href="#a59e76258cd67c9bb27b2b95066185d8f">More...</a><br /></td></tr>
<tr class="separator:a59e76258cd67c9bb27b2b95066185d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e8a0f2aa33ab591476b27dbba5c19d"><td class="memItemLeft" align="right" valign="top">array&lt; <a class="el" href="classCaretaker_1_1PrimaryVitals.html">PrimaryVitals</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a45e8a0f2aa33ab591476b27dbba5c19d">GetPrimaryVitals</a> ()</td></tr>
<tr class="memdesc:a45e8a0f2aa33ab591476b27dbba5c19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to poll primary vitals.  <a href="#a45e8a0f2aa33ab591476b27dbba5c19d">More...</a><br /></td></tr>
<tr class="separator:a45e8a0f2aa33ab591476b27dbba5c19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178b12719192cecd5d6788d8ca2cf5bb"><td class="memItemLeft" align="right" valign="top">array&lt; <a class="el" href="classCaretaker_1_1SecondaryVitals.html">SecondaryVitals</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a178b12719192cecd5d6788d8ca2cf5bb">GetSecondaryVitals</a> ()</td></tr>
<tr class="memdesc:a178b12719192cecd5d6788d8ca2cf5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to poll secondary vitals.  <a href="#a178b12719192cecd5d6788d8ca2cf5bb">More...</a><br /></td></tr>
<tr class="separator:a178b12719192cecd5d6788d8ca2cf5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45317239664c9fc1f76b7ad8c28eef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCaretaker_1_1WaveformDataPoints.html">WaveformDataPoints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#ac45317239664c9fc1f76b7ad8c28eef0">GetPulseRateWaveformDataPoints</a> ()</td></tr>
<tr class="memdesc:ac45317239664c9fc1f76b7ad8c28eef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to poll pulse rate waveform data points.  <a href="#ac45317239664c9fc1f76b7ad8c28eef0">More...</a><br /></td></tr>
<tr class="separator:ac45317239664c9fc1f76b7ad8c28eef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be1074eae455eef82774e976652387b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCaretaker_1_1WaveformDataPoints.html">WaveformDataPoints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a8be1074eae455eef82774e976652387b">GetPulsePressureWaveformDataPoints</a> ()</td></tr>
<tr class="memdesc:a8be1074eae455eef82774e976652387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to poll pulse pressure waveform data points.  <a href="#a8be1074eae455eef82774e976652387b">More...</a><br /></td></tr>
<tr class="separator:a8be1074eae455eef82774e976652387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6b9916e6543ac24537bcf133793329"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a7f6b9916e6543ac24537bcf133793329">IncrementCuffPressure</a> ()</td></tr>
<tr class="memdesc:a7f6b9916e6543ac24537bcf133793329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the cuff pressure in 10 mmHg increment.  <a href="#a7f6b9916e6543ac24537bcf133793329">More...</a><br /></td></tr>
<tr class="separator:a7f6b9916e6543ac24537bcf133793329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91efadadc50a7b37c24f99280a5042c4"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a91efadadc50a7b37c24f99280a5042c4">DecrementCuffPressure</a> ()</td></tr>
<tr class="memdesc:a91efadadc50a7b37c24f99280a5042c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the cuff pressure in 10 mmHg increment.  <a href="#a91efadadc50a7b37c24f99280a5042c4">More...</a><br /></td></tr>
<tr class="separator:a91efadadc50a7b37c24f99280a5042c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8037a8af0459a0fe94a4c8ce79adfa2c"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a8037a8af0459a0fe94a4c8ce79adfa2c">VentCuff</a> ()</td></tr>
<tr class="memdesc:a8037a8af0459a0fe94a4c8ce79adfa2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deflates the cuff pressure.  <a href="#a8037a8af0459a0fe94a4c8ce79adfa2c">More...</a><br /></td></tr>
<tr class="separator:a8037a8af0459a0fe94a4c8ce79adfa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd2df9270afc9e9d1c18458a8bf67d0"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a0bd2df9270afc9e9d1c18458a8bf67d0">PeformDiagnosticsFlush</a> ()</td></tr>
<tr class="memdesc:a0bd2df9270afc9e9d1c18458a8bf67d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the device diagnostic plumbing tree.  <a href="#a0bd2df9270afc9e9d1c18458a8bf67d0">More...</a><br /></td></tr>
<tr class="separator:a0bd2df9270afc9e9d1c18458a8bf67d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58abb686bc12186e439a311f5af8bfe"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#ae58abb686bc12186e439a311f5af8bfe">WriteSnrMinimum</a> (Int32 snr)</td></tr>
<tr class="memdesc:ae58abb686bc12186e439a311f5af8bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the device noise filter parameter.  <a href="#ae58abb686bc12186e439a311f5af8bfe">More...</a><br /></td></tr>
<tr class="separator:ae58abb686bc12186e439a311f5af8bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6f6027a8f5841bf50c0cc64c698818"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a6e6f6027a8f5841bf50c0cc64c698818">ReadSnrMinimum</a> ()</td></tr>
<tr class="memdesc:a6e6f6027a8f5841bf50c0cc64c698818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the device noise filter parameter.  <a href="#a6e6f6027a8f5841bf50c0cc64c698818">More...</a><br /></td></tr>
<tr class="separator:a6e6f6027a8f5841bf50c0cc64c698818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf40b2d8eb3f42399ad94070171249ac"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#abf40b2d8eb3f42399ad94070171249ac">WriteMotionTolerance</a> (Int32 value)</td></tr>
<tr class="memdesc:abf40b2d8eb3f42399ad94070171249ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the device motion tolerance parameter.  <a href="#abf40b2d8eb3f42399ad94070171249ac">More...</a><br /></td></tr>
<tr class="separator:abf40b2d8eb3f42399ad94070171249ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834ca451afa581f0ab8f849fd49242ce"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a834ca451afa581f0ab8f849fd49242ce">ReadMotionTolerance</a> ()</td></tr>
<tr class="memdesc:a834ca451afa581f0ab8f849fd49242ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the device motion tolerance parameter.  <a href="#a834ca451afa581f0ab8f849fd49242ce">More...</a><br /></td></tr>
<tr class="separator:a834ca451afa581f0ab8f849fd49242ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af477d4844d55ddfbbadb15ec03d13f50"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#af477d4844d55ddfbbadb15ec03d13f50">TurnDisplayOff</a> ()</td></tr>
<tr class="memdesc:af477d4844d55ddfbbadb15ec03d13f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the device display screen off.  <a href="#af477d4844d55ddfbbadb15ec03d13f50">More...</a><br /></td></tr>
<tr class="separator:af477d4844d55ddfbbadb15ec03d13f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839eea883fcbee20ff00bc8bc60b10fa"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a839eea883fcbee20ff00bc8bc60b10fa">TurnDisplayOn</a> ()</td></tr>
<tr class="memdesc:a839eea883fcbee20ff00bc8bc60b10fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns the device display screen on.  <a href="#a839eea883fcbee20ff00bc8bc60b10fa">More...</a><br /></td></tr>
<tr class="separator:a839eea883fcbee20ff00bc8bc60b10fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c606666dfc77b023b46d04c98c62212"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a6c606666dfc77b023b46d04c98c62212">ReadDisplayState</a> ()</td></tr>
<tr class="memdesc:a6c606666dfc77b023b46d04c98c62212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the display state.  <a href="#a6c606666dfc77b023b46d04c98c62212">More...</a><br /></td></tr>
<tr class="separator:a6c606666dfc77b023b46d04c98c62212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c47f157bff768ef4729016fa0d13b4c"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a3c47f157bff768ef4729016fa0d13b4c">Recalibrate</a> ()</td></tr>
<tr class="memdesc:a3c47f157bff768ef4729016fa0d13b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalibrate blood pressure measurements.  <a href="#a3c47f157bff768ef4729016fa0d13b4c">More...</a><br /></td></tr>
<tr class="separator:a3c47f157bff768ef4729016fa0d13b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15415878a04e3a2b14b797ef5534eeec"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a15415878a04e3a2b14b797ef5534eeec">WriteRecalibrationInterval</a> (UInt32 interval)</td></tr>
<tr class="memdesc:a15415878a04e3a2b14b797ef5534eeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the calibration interval.  <a href="#a15415878a04e3a2b14b797ef5534eeec">More...</a><br /></td></tr>
<tr class="separator:a15415878a04e3a2b14b797ef5534eeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248e452d39ef934369b2e7d116c36a0b"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a248e452d39ef934369b2e7d116c36a0b">ReadRecalibrationInterval</a> ()</td></tr>
<tr class="memdesc:a248e452d39ef934369b2e7d116c36a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the calibration interval.  <a href="#a248e452d39ef934369b2e7d116c36a0b">More...</a><br /></td></tr>
<tr class="separator:a248e452d39ef934369b2e7d116c36a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587924d99d5e6daca01dca7afb269a8d"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a587924d99d5e6daca01dca7afb269a8d">WriteWaveformClampSetting</a> (Byte value)</td></tr>
<tr class="memdesc:a587924d99d5e6daca01dca7afb269a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the setting to enable or disable clamping the waveforms.  <a href="#a587924d99d5e6daca01dca7afb269a8d">More...</a><br /></td></tr>
<tr class="separator:a587924d99d5e6daca01dca7afb269a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea60a6bb86f38f6ae20e86a0ad43868"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#abea60a6bb86f38f6ae20e86a0ad43868">ReadWaveformClampSetting</a> ()</td></tr>
<tr class="memdesc:abea60a6bb86f38f6ae20e86a0ad43868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the waveform clamping setting.  <a href="#abea60a6bb86f38f6ae20e86a0ad43868">More...</a><br /></td></tr>
<tr class="separator:abea60a6bb86f38f6ae20e86a0ad43868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728b54de5fcc10ed7d0176bb5a1dc91a"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a728b54de5fcc10ed7d0176bb5a1dc91a">WriteVitalsFilterSetting</a> (Byte value)</td></tr>
<tr class="memdesc:a728b54de5fcc10ed7d0176bb5a1dc91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the filter settings to enable or disable filtering outlier vitals measurements.  <a href="#a728b54de5fcc10ed7d0176bb5a1dc91a">More...</a><br /></td></tr>
<tr class="separator:a728b54de5fcc10ed7d0176bb5a1dc91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076c23dabc4734c6dcd6808d1f93fb26"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a076c23dabc4734c6dcd6808d1f93fb26">ReadVitalsFilterSetting</a> ()</td></tr>
<tr class="memdesc:a076c23dabc4734c6dcd6808d1f93fb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current filter settings to enable or disable filtering outlier vitals measurements.  <a href="#a076c23dabc4734c6dcd6808d1f93fb26">More...</a><br /></td></tr>
<tr class="separator:a076c23dabc4734c6dcd6808d1f93fb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435ff3459b62f053dc9f56eb48a39b5a"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a435ff3459b62f053dc9f56eb48a39b5a">ReadPersistentLog</a> ()</td></tr>
<tr class="memdesc:a435ff3459b62f053dc9f56eb48a39b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the device logs.  <a href="#a435ff3459b62f053dc9f56eb48a39b5a">More...</a><br /></td></tr>
<tr class="separator:a435ff3459b62f053dc9f56eb48a39b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17083e351571c629e7771c731154cd44"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a17083e351571c629e7771c731154cd44">EnableSimulationMode</a> (Boolean mode)</td></tr>
<tr class="memdesc:a17083e351571c629e7771c731154cd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the device simulation mode.  <a href="#a17083e351571c629e7771c731154cd44">More...</a><br /></td></tr>
<tr class="separator:a17083e351571c629e7771c731154cd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d32d8f6c3165bac72c0b639be967eff"><td class="memItemLeft" align="right" valign="top">Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a7d32d8f6c3165bac72c0b639be967eff">ClearStatus</a> ()</td></tr>
<tr class="memdesc:a7d32d8f6c3165bac72c0b639be967eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the device status.  <a href="#a7d32d8f6c3165bac72c0b639be967eff">More...</a><br /></td></tr>
<tr class="separator:a7d32d8f6c3165bac72c0b639be967eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a797e2d5f66fb1b978cd779ea14286829"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a797e2d5f66fb1b978cd779ea14286829">SetLibraryLogLevel</a> (Int32 level)</td></tr>
<tr class="memdesc:a797e2d5f66fb1b978cd779ea14286829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the library log level.  <a href="#a797e2d5f66fb1b978cd779ea14286829">More...</a><br /></td></tr>
<tr class="separator:a797e2d5f66fb1b978cd779ea14286829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd9baaa21c213cb11b3fcea0a501f29"><td class="memItemLeft" align="right" valign="top"><a id="a6cd9baaa21c213cb11b3fcea0a501f29"></a>
static Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a6cd9baaa21c213cb11b3fcea0a501f29">RedirectLibraryLogs</a> ()</td></tr>
<tr class="memdesc:a6cd9baaa21c213cb11b3fcea0a501f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirects library logging to plain-text file <em>libcaretaker.log</em> <br /></td></tr>
<tr class="separator:a6cd9baaa21c213cb11b3fcea0a501f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a54920562d5319a4da094a3170ef2abaa"><td class="memItemLeft" align="right" valign="top"><a id="a54920562d5319a4da094a3170ef2abaa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCaretaker_1_1Device.html#a54920562d5319a4da094a3170ef2abaa">!Device</a> ()</td></tr>
<tr class="memdesc:a54920562d5319a4da094a3170ef2abaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizer Gets called when the object's memory is about to be reclaimed by the garbage collector. <br /></td></tr>
<tr class="separator:a54920562d5319a4da094a3170ef2abaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Managed class for .NET applications to monitor the Caretaker device. </p>
<p>This class is a wrapper to the unmanaged libcaretaker_dynamic.dll library to allow .NET applications to monitor the Caretaker device. The class is defined in the managed libcaretaker_clr.dll library so the application must reference libcaretaker_clr.dll to access this and supporting managed classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2f988cc0af06179d790bc7e4363c70e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f988cc0af06179d790bc7e4363c70e5">&#9670;&nbsp;</a></span>Device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Caretaker::Device::Device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCaretaker_1_1DeviceObserver.html">DeviceObserver</a>^&#160;</td>
          <td class="paramname"><em>observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Boolean&#160;</td>
          <td class="paramname"><em>autoReconnect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classCaretaker_1_1Device.html" title="Managed class for .NET applications to monitor the Caretaker device. ">Device</a> instance. </p>
<p>The device instance represents a proxy to the Caretaker device to which it has established a connection and provides an interface for the application to monitor the Caretaker device.</p>
<p><b>IMPORTANT</b> The application must call <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> to explicitly release unmanaged library resources allocated for the device instance when it is no longer needed. Not calling <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> will leave unmanaged resources alive and unaccessible (i.e, zombie resources) that could still maintain the connection to the device after the device instance goes out of scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The application <a class="el" href="classCaretaker_1_1DeviceObserver.html" title="Managed class defining the application observer interface to receive real-time notifications. ">DeviceObserver</a> implementation to receive Caretaker numeric and waveform data and event notifications in real-time. Passing null disables notifications and the application must call getters to poll for numeric data.</td></tr>
    <tr><td class="paramname">autoReconnect</td><td>Set this argument to true to reconnect automatically after the connection is lost. On reconnects, data streams will be re-enabled automatically if enabled prior to the disconnect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af070b8fa2467f159f0eb527d553ff9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af070b8fa2467f159f0eb527d553ff9e4">&#9670;&nbsp;</a></span>~Device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Caretaker::Device::~Device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Gets called when the object is about to go out of scope, .i.e, destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa32373956203d4dd418477d8cd55b8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32373956203d4dd418477d8cd55b8f7">&#9670;&nbsp;</a></span>ReleaseResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Caretaker::Device::ReleaseResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release unmanaged library resources allocated for the <a class="el" href="classCaretaker_1_1Device.html" title="Managed class for .NET applications to monitor the Caretaker device. ">Device</a> instance. </p>
<p>The application must call this method to clean things up in the unmanaged code when the <a class="el" href="classCaretaker_1_1Device.html" title="Managed class for .NET applications to monitor the Caretaker device. ">Device</a> instance is no longer needed. Note for C++ applications, the <a class="el" href="classCaretaker_1_1Device.html" title="Managed class for .NET applications to monitor the Caretaker device. ">Device</a> destructor <a class="el" href="classCaretaker_1_1Device.html#af070b8fa2467f159f0eb527d553ff9e4" title="Destructor. ">~Device()</a> may not be called so <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> must be called explicitly to release library resources. Not calling <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> will leave unmanaged resources alive and unaccessible (i.e, zombie resources) that could still maintain the connection to the Caretaker device after the <a class="el" href="classCaretaker_1_1Device.html" title="Managed class for .NET applications to monitor the Caretaker device. ">Device</a> instance goes out of scope.</p>
<p><b>IMPORTANT:</b> The application must not call <a class="el" href="classCaretaker_1_1Device.html#a245cb442071bbac2a9abe4c46aa5ac69" title="Initiates disconnecting from the remote device if connected. ">Disconnect()</a> or <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> from any <a class="el" href="classCaretaker_1_1DeviceObserver.html" title="Managed class defining the application observer interface to receive real-time notifications. ">DeviceObserver</a> methods. The <a class="el" href="classCaretaker_1_1DeviceObserver.html" title="Managed class defining the application observer interface to receive real-time notifications. ">DeviceObserver</a> methods are called from unmanaged threads that the aforementioned methods attempt to kill. As such, <a class="el" href="classCaretaker_1_1Device.html#a245cb442071bbac2a9abe4c46aa5ac69" title="Initiates disconnecting from the remote device if connected. ">Disconnect()</a> or <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> must only be called from an application thread, otherwise the application could deadlock.</p>
<p>Also, <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> invalidates the device instance so after calling it the application should set the <a class="el" href="classCaretaker_1_1Device.html" title="Managed class for .NET applications to monitor the Caretaker device. ">Device</a> reference to null to prevent further use.</p>
<p>Also, <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> may delay the calling application thread for a couple seconds as it waits for unmanaged\ threads to exit. </p>

</div>
</div>
<a id="a23dc37a0ef2ac55ca77cd913663e18fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23dc37a0ef2ac55ca77cd913663e18fa">&#9670;&nbsp;</a></span>StartScan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::StartScan </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates scanning for nearby Caretaker devices. </p>
<p>If the serial number or MAC address of the Caretaker device is known, call <a class="el" href="classCaretaker_1_1Device.html#a7a541e1094860510352d6c1443be89d5" title="Initiates connecting to the Caretaker device with the specified serial number. ">ConnectToSerialNumber()</a> or <a class="el" href="classCaretaker_1_1Device.html#ad6e7e189884e2fbcfea61559fc54f583" title="Initiates connecting to the Caretaker device with the specified MAC address. ">ConnectToMacAddress()</a> to establish connection with the device. Otherwise, call <a class="el" href="classCaretaker_1_1Device.html#a23dc37a0ef2ac55ca77cd913663e18fa" title="Initiates scanning for nearby Caretaker devices. ">StartScan()</a> to scan for nearby Caretaker devices that are advertising. Each device discovered will be notified with <a class="el" href="classCaretaker_1_1DeviceObserver.html#a4bc95c4f5bed37a1df636c9f15c50b22" title="Notification sent to report a discovered device after the application called Device::StartScan(). ">DeviceObserver::OnDeviceDiscovered()</a> passing the discovered device name, serial number, and MAC address to the application. The application must then call <a class="el" href="classCaretaker_1_1Device.html#a7a541e1094860510352d6c1443be89d5" title="Initiates connecting to the Caretaker device with the specified serial number. ">ConnectToSerialNumber()</a> or <a class="el" href="classCaretaker_1_1Device.html#ad6e7e189884e2fbcfea61559fc54f583" title="Initiates connecting to the Caretaker device with the specified MAC address. ">ConnectToMacAddress()</a> to connect to the desired, discovered device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Milliseconds to timeout the scan operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if scanning was initiated and false otherwise. </dd></dl>

</div>
</div>
<a id="a7a541e1094860510352d6c1443be89d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a541e1094860510352d6c1443be89d5">&#9670;&nbsp;</a></span>ConnectToSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ConnectToSerialNumber </td>
          <td>(</td>
          <td class="paramtype">String^&#160;</td>
          <td class="paramname"><em>sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates connecting to the Caretaker device with the specified serial number. </p>
<p>The Caretaker device must be advertising for this method to establish connection.</p>
<p>If the connection sequence was initiated, <a class="el" href="classCaretaker_1_1DeviceObserver.html#ae84001fac443605574ddd01aa662124a" title="Notification sent to report Device::Connect() and Device::Disconnect() status. ">DeviceObserver::OnConnectionStatus()</a> will be notified later with the connection status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sn</td><td>Serial number of the Caretaker device to connect to. Passing a null or empty address returns failure. </td></tr>
    <tr><td class="paramname">timeout</td><td>Milliseconds to timeout connecting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the connection sequence was initiated and false otherwise. This method also returns false if a previous connection sequence is executing or if the application is already connected to a device. To workaround this scenario, call <a class="el" href="classCaretaker_1_1Device.html#a245cb442071bbac2a9abe4c46aa5ac69" title="Initiates disconnecting from the remote device if connected. ">Disconnect()</a> before calling this method. </dd></dl>

</div>
</div>
<a id="ad6e7e189884e2fbcfea61559fc54f583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e7e189884e2fbcfea61559fc54f583">&#9670;&nbsp;</a></span>ConnectToMacAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ConnectToMacAddress </td>
          <td>(</td>
          <td class="paramtype">String^&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates connecting to the Caretaker device with the specified MAC address. </p>
<p>The Caretaker device must be advertising for this method to establish connection.</p>
<p>If the connection sequence was initiated, <a class="el" href="classCaretaker_1_1DeviceObserver.html#ae84001fac443605574ddd01aa662124a" title="Notification sent to report Device::Connect() and Device::Disconnect() status. ">DeviceObserver::OnConnectionStatus()</a> will be notified later with the connection status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>MAC address of the Caretaker device to connect to. Passing a null or empty address returns failure. </td></tr>
    <tr><td class="paramname">timeout</td><td>Milliseconds to timeout connecting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the connection sequence was initiated and false otherwise. This method also returns false if a previous connection sequence is executing or if the application is already connected to a device. To workaround this scenario, call <a class="el" href="classCaretaker_1_1Device.html#a245cb442071bbac2a9abe4c46aa5ac69" title="Initiates disconnecting from the remote device if connected. ">Disconnect()</a> before calling this method. </dd></dl>

</div>
</div>
<a id="a4afc0dabbaf6cac1e91256af4b53c02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afc0dabbaf6cac1e91256af4b53c02e">&#9670;&nbsp;</a></span>ConnectToAny()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ConnectToAny </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates connecting to any Caretaker device that is advertising for a connection. </p>
<p>If the connection sequence was initiated, <a class="el" href="classCaretaker_1_1DeviceObserver.html#ae84001fac443605574ddd01aa662124a" title="Notification sent to report Device::Connect() and Device::Disconnect() status. ">DeviceObserver::OnConnectionStatus()</a> will be notified later with the connection status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Milliseconds to timeout connecting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the connection sequence was initiated and false otherwise. This method also returns false if a previous connection sequence is executing or if the application is already connected to a device. To workaround this scenario, call <a class="el" href="classCaretaker_1_1Device.html#a245cb442071bbac2a9abe4c46aa5ac69" title="Initiates disconnecting from the remote device if connected. ">Disconnect()</a> before calling this method. </dd></dl>

</div>
</div>
<a id="a245cb442071bbac2a9abe4c46aa5ac69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245cb442071bbac2a9abe4c46aa5ac69">&#9670;&nbsp;</a></span>Disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::Disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates disconnecting from the remote device if connected. </p>
<p>If the disconnection sequence was initiated, <a class="el" href="classCaretaker_1_1DeviceObserver.html#ae84001fac443605574ddd01aa662124a" title="Notification sent to report Device::Connect() and Device::Disconnect() status. ">DeviceObserver::OnConnectionStatus()</a> will be notified later with connection status.</p>
<p><b>IMPORTANT:</b> The application must not call <a class="el" href="classCaretaker_1_1Device.html#a245cb442071bbac2a9abe4c46aa5ac69" title="Initiates disconnecting from the remote device if connected. ">Disconnect()</a> or <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> from any <a class="el" href="classCaretaker_1_1DeviceObserver.html" title="Managed class defining the application observer interface to receive real-time notifications. ">DeviceObserver</a> methods. The <a class="el" href="classCaretaker_1_1DeviceObserver.html" title="Managed class defining the application observer interface to receive real-time notifications. ">DeviceObserver</a> methods are called from unmanaged threads that the aforementioned methods attempt to kill. As such, <a class="el" href="classCaretaker_1_1Device.html#a245cb442071bbac2a9abe4c46aa5ac69" title="Initiates disconnecting from the remote device if connected. ">Disconnect()</a> or <a class="el" href="classCaretaker_1_1Device.html#aa32373956203d4dd418477d8cd55b8f7" title="Release unmanaged library resources allocated for the Device instance. ">ReleaseResources()</a> must only be called from an application thread, otherwise the application could deadlock.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if disconnecting from the device was initiated and false otherwise. </dd></dl>

</div>
</div>
<a id="af6adb913de3660f2665e3286192d091c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6adb913de3660f2665e3286192d091c">&#9670;&nbsp;</a></span>StartAutoCal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::StartAutoCal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__windows__managed__api.html#gabc29121ccac1aa1261962767a550112b">PatientPosture</a>&#160;</td>
          <td class="paramname"><em>posture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an automatic calibration and then start taking measurements if connected. </p>
<p>If true is returned, <a class="el" href="classCaretaker_1_1DeviceObserver.html#a0823ae252688f7d89a2e188f40f44a25" title="Notification sent to report Device::StartAutoCal() and Device::StartManualCal() status. ">DeviceObserver::OnStartStatus()</a> and OnDeviceStatus() will be notified later with start and calibration status, respectively.</p>
<p>The application will start receiving data if the start process completed successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posture</td><td>The patient posture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if start was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="aacbc203a2dae908d791241588e3c810a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbc203a2dae908d791241588e3c810a">&#9670;&nbsp;</a></span>StartManualCal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::StartManualCal </td>
          <td>(</td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>systolic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>diastolic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a manual calibration and then start taking measurements if connected. </p>
<p>If true is returned, <a class="el" href="classCaretaker_1_1DeviceObserver.html#a0823ae252688f7d89a2e188f40f44a25" title="Notification sent to report Device::StartAutoCal() and Device::StartManualCal() status. ">DeviceObserver::OnStartStatus()</a> and OnDeviceStatus() will be notified later with start and calibration status, respectively.</p>
<p>The application will start receiving data if the start process completed successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">systolic</td><td>Initial systolic pressure. Acceptable range [30, 250]. </td></tr>
    <tr><td class="paramname">diastolic</td><td>Initial diastolic pressure. Acceptable range [10, 150].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if start was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a50e993b04a8cb5d4486843124679c049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e993b04a8cb5d4486843124679c049">&#9670;&nbsp;</a></span>Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::Stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this method after calling <a class="el" href="classCaretaker_1_1Device.html#af6adb913de3660f2665e3286192d091c" title="Perform an automatic calibration and then start taking measurements if connected. ...">StartAutoCal()</a> or <a class="el" href="classCaretaker_1_1Device.html#aacbc203a2dae908d791241588e3c810a" title="Perform a manual calibration and then start taking measurements if connected. ">StartManualCal()</a> to stop the device. </p>
<p>This will also stop data and device status notifications.</p>
<p>If true is returned, <a class="el" href="classCaretaker_1_1DeviceObserver.html#abbcdb574930f0b7ba1b2314bdd6116af" title="Notification sent to report Device::Stop() status. ">DeviceObserver::OnStopStatus()</a> will be notified later with stop status.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if stop was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="aca1082a83246988bd7de09f930cbf541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1082a83246988bd7de09f930cbf541">&#9670;&nbsp;</a></span>Calibrating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::Calibrating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is calibrating, and false otherwise. </p>
<p>Note this is the same as <a class="el" href="classCaretaker_1_1Device.html#a4b560a668cc920d21e0fd0563ed0273c" title="Method to poll device status. ">GetDeviceStatus()</a>-&gt;calibrating. </p>

</div>
</div>
<a id="a47d8d3fe5a08b656780f42540eb2e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d8d3fe5a08b656780f42540eb2e318">&#9670;&nbsp;</a></span>Calibrated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::Calibrated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is calibrated, and false otherwise. </p>
<p>Note this is the same as <a class="el" href="classCaretaker_1_1Device.html#a4b560a668cc920d21e0fd0563ed0273c" title="Method to poll device status. ">GetDeviceStatus()</a>-&gt;calibrated. </p>

</div>
</div>
<a id="af3eca610dc4bbca4b9eaf45d9c1e275d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3eca610dc4bbca4b9eaf45d9c1e275d">&#9670;&nbsp;</a></span>CalibrationFailed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::CalibrationFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device was calibrating and the calibration failed, and false otherwise. </p>
<p>This method summarizes the various <a class="el" href="classCaretaker_1_1DeviceStatus.html" title="Managed class defining device status. ">DeviceStatus</a> flags reporting calibration failure. </p>

</div>
</div>
<a id="a6485652d4602825c0ded98914d0d464f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6485652d4602825c0ded98914d0d464f">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String Caretaker::Device::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the device friendly name or null if the name is not available. </p>
<dl class="section note"><dt>Note</dt><dd>The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns null. </dd></dl>

</div>
</div>
<a id="a8a3a678b6819ca0f8dcacf9da56b63fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3a678b6819ca0f8dcacf9da56b63fa">&#9670;&nbsp;</a></span>GetMacAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String Caretaker::Device::GetMacAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the device MAC address or null if the MAC address is not available. </p>
<dl class="section note"><dt>Note</dt><dd>The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns null </dd></dl>

</div>
</div>
<a id="ae8ad4e9da3fd413eab59019eebda4909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ad4e9da3fd413eab59019eebda4909">&#9670;&nbsp;</a></span>GetSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String Caretaker::Device::GetSerialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the device serial number or null if the serial number is not available. </p>
<dl class="section note"><dt>Note</dt><dd>The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns null </dd></dl>

</div>
</div>
<a id="af7394f2c403b504aa23dc67324a3ef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7394f2c403b504aa23dc67324a3ef2d">&#9670;&nbsp;</a></span>GetFirmwareVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String Caretaker::Device::GetFirmwareVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the device firmware version or null if the firmware version is not available. </p>
<dl class="section note"><dt>Note</dt><dd>The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns null </dd></dl>

</div>
</div>
<a id="a2a08418ed245269af880bf8a08a89083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a08418ed245269af880bf8a08a89083">&#9670;&nbsp;</a></span>GetHardwareVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String Caretaker::Device::GetHardwareVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the device hardware version or null if the hardware version is not available. </p>
<dl class="section note"><dt>Note</dt><dd>The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns null. </dd></dl>

</div>
</div>
<a id="a4b560a668cc920d21e0fd0563ed0273c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b560a668cc920d21e0fd0563ed0273c">&#9670;&nbsp;</a></span>GetDeviceStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCaretaker_1_1DeviceStatus.html">DeviceStatus</a> Caretaker::Device::GetDeviceStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to poll device status. </p>
<dl class="section return"><dt>Returns</dt><dd>The last device status received from the device or null if it is not available. </dd></dl>

</div>
</div>
<a id="a34b9e8e39d130935edb278b6f3a2e8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b9e8e39d130935edb278b6f3a2e8ad">&#9670;&nbsp;</a></span>GetBatteryStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCaretaker_1_1BatteryStatus.html">BatteryStatus</a> Caretaker::Device::GetBatteryStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to poll battery status. </p>
<dl class="section return"><dt>Returns</dt><dd>The last battery status received from the device or null if it is not available. </dd></dl>

</div>
</div>
<a id="a59e76258cd67c9bb27b2b95066185d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e76258cd67c9bb27b2b95066185d8f">&#9670;&nbsp;</a></span>GetCuffStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCaretaker_1_1CuffStatus.html">CuffStatus</a> Caretaker::Device::GetCuffStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to poll cuff status. </p>
<dl class="section return"><dt>Returns</dt><dd>The last cuff status received from the device or null if it is not available. </dd></dl>

</div>
</div>
<a id="a45e8a0f2aa33ab591476b27dbba5c19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e8a0f2aa33ab591476b27dbba5c19d">&#9670;&nbsp;</a></span>GetPrimaryVitals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;<a class="el" href="classCaretaker_1_1PrimaryVitals.html">PrimaryVitals</a>&gt; Caretaker::Device::GetPrimaryVitals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to poll primary vitals. </p>
<dl class="section return"><dt>Returns</dt><dd>Array of last primary vitals received from the device or null if they are not available. </dd></dl>

</div>
</div>
<a id="a178b12719192cecd5d6788d8ca2cf5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178b12719192cecd5d6788d8ca2cf5bb">&#9670;&nbsp;</a></span>GetSecondaryVitals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;<a class="el" href="classCaretaker_1_1SecondaryVitals.html">SecondaryVitals</a>&gt; Caretaker::Device::GetSecondaryVitals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to poll secondary vitals. </p>
<dl class="section return"><dt>Returns</dt><dd>The last secondary vitals received from the device or null if they are not available. </dd></dl>

</div>
</div>
<a id="ac45317239664c9fc1f76b7ad8c28eef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45317239664c9fc1f76b7ad8c28eef0">&#9670;&nbsp;</a></span>GetPulseRateWaveformDataPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCaretaker_1_1WaveformDataPoints.html">WaveformDataPoints</a> Caretaker::Device::GetPulseRateWaveformDataPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to poll pulse rate waveform data points. </p>
<dl class="section note"><dt>Note</dt><dd>If the application is polling, this method must be called at least 4 times per second to not drop data. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last pulse rate data points received from the device or null if they are not available. </dd></dl>

</div>
</div>
<a id="a8be1074eae455eef82774e976652387b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be1074eae455eef82774e976652387b">&#9670;&nbsp;</a></span>GetPulsePressureWaveformDataPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCaretaker_1_1WaveformDataPoints.html">WaveformDataPoints</a> Caretaker::Device::GetPulsePressureWaveformDataPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to poll pulse pressure waveform data points. </p>
<dl class="section note"><dt>Note</dt><dd>If the application is polling, this method must be called at least 4 times per second to not drop data. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last pulse rate data points received from the device or null if they are not available. </dd></dl>

</div>
</div>
<a id="a7f6b9916e6543ac24537bcf133793329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6b9916e6543ac24537bcf133793329">&#9670;&nbsp;</a></span>IncrementCuffPressure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::IncrementCuffPressure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the cuff pressure in 10 mmHg increment. </p>
<p>This method issues a write request to the device to adjust the cuff pressure up 10 mmHg and may take a couple seconds to take effect.</p>
<p>Use <a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f" title="Method to poll cuff status. ">GetCuffStatus()</a> to monitor the target and actual cuff pressure values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a91efadadc50a7b37c24f99280a5042c4" title="Decrements the cuff pressure in 10 mmHg increment. ">DecrementCuffPressure</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f" title="Method to poll cuff status. ">GetCuffStatus</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a8037a8af0459a0fe94a4c8ce79adfa2c" title="Deflates the cuff pressure. ">VentCuff</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a91efadadc50a7b37c24f99280a5042c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91efadadc50a7b37c24f99280a5042c4">&#9670;&nbsp;</a></span>DecrementCuffPressure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::DecrementCuffPressure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the cuff pressure in 10 mmHg increment. </p>
<p>This method issues a write request to the device to adjust the cuff pressure down 10 mmHg and may take a couple seconds to effect.</p>
<p>Use <a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f" title="Method to poll cuff status. ">GetCuffStatus()</a> to monitor the target and actual cuff pressure values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a7f6b9916e6543ac24537bcf133793329" title="Increments the cuff pressure in 10 mmHg increment. ">IncrementCuffPressure</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f" title="Method to poll cuff status. ">GetCuffStatus</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a8037a8af0459a0fe94a4c8ce79adfa2c" title="Deflates the cuff pressure. ">VentCuff</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a8037a8af0459a0fe94a4c8ce79adfa2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8037a8af0459a0fe94a4c8ce79adfa2c">&#9670;&nbsp;</a></span>VentCuff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::VentCuff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deflates the cuff pressure. </p>
<p>This method issues a write request to the device to deflate cuff pressure.</p>
<p>Use <a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f" title="Method to poll cuff status. ">GetCuffStatus()</a> to monitor the target and actual cuff pressure values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a91efadadc50a7b37c24f99280a5042c4" title="Decrements the cuff pressure in 10 mmHg increment. ">DecrementCuffPressure</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a91efadadc50a7b37c24f99280a5042c4" title="Decrements the cuff pressure in 10 mmHg increment. ">DecrementCuffPressure</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f" title="Method to poll cuff status. ">GetCuffStatus</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a0bd2df9270afc9e9d1c18458a8bf67d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd2df9270afc9e9d1c18458a8bf67d0">&#9670;&nbsp;</a></span>PeformDiagnosticsFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::PeformDiagnosticsFlush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the device diagnostic plumbing tree. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="ae58abb686bc12186e439a311f5af8bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58abb686bc12186e439a311f5af8bfe">&#9670;&nbsp;</a></span>WriteSnrMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::WriteSnrMinimum </td>
          <td>(</td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>snr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the device noise filter parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snr</td><td>The minimum signal-to-noise value. Acceptable range [0, 100].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f" title="Method to poll cuff status. ">GetCuffStatus</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a6e6f6027a8f5841bf50c0cc64c698818" title="Reads the device noise filter parameter. ">ReadSnrMinimum</a> </dd></dl>

</div>
</div>
<a id="a6e6f6027a8f5841bf50c0cc64c698818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6f6027a8f5841bf50c0cc64c698818">&#9670;&nbsp;</a></span>ReadSnrMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ReadSnrMinimum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the device noise filter parameter. </p>
<p>Use <a class="el" href="classCaretaker_1_1Device.html#a59e76258cd67c9bb27b2b95066185d8f" title="Method to poll cuff status. ">GetCuffStatus()</a> to monitor the signal-to-noise (snr) ratio at the device. Use <a class="el" href="classCaretaker_1_1Device.html#a6e6f6027a8f5841bf50c0cc64c698818" title="Reads the device noise filter parameter. ">ReadSnrMinimum()</a> to get an immediate reading of the current value.</p>
<p>On success, the result is notified later with <a class="el" href="classCaretaker_1_1DeviceObserver.html#a6dd01540471445e2ce475a48522a6dde" title="Notification sent to report Device::ReadSnrMinimum() transaction result. ">DeviceObserver::OnReadSnrMinimum()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="abf40b2d8eb3f42399ad94070171249ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf40b2d8eb3f42399ad94070171249ac">&#9670;&nbsp;</a></span>WriteMotionTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::WriteMotionTolerance </td>
          <td>(</td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the device motion tolerance parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Timeout in seconds. Acceptable range [0, 30].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a834ca451afa581f0ab8f849fd49242ce" title="Reads the device motion tolerance parameter. ">ReadMotionTolerance</a> </dd></dl>

</div>
</div>
<a id="a834ca451afa581f0ab8f849fd49242ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834ca451afa581f0ab8f849fd49242ce">&#9670;&nbsp;</a></span>ReadMotionTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ReadMotionTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the device motion tolerance parameter. </p>
<p>On success, the result is notified later with <a class="el" href="classCaretaker_1_1DeviceObserver.html#ae4770bc3345a9c0e8342ec9782d38151" title="Notification sent to report Device::ReadMotionTolerance() transaction result. ">DeviceObserver::OnReadMotionTolerance()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="af477d4844d55ddfbbadb15ec03d13f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af477d4844d55ddfbbadb15ec03d13f50">&#9670;&nbsp;</a></span>TurnDisplayOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::TurnDisplayOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns the device display screen off. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a839eea883fcbee20ff00bc8bc60b10fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839eea883fcbee20ff00bc8bc60b10fa">&#9670;&nbsp;</a></span>TurnDisplayOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::TurnDisplayOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns the device display screen on. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a6c606666dfc77b023b46d04c98c62212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c606666dfc77b023b46d04c98c62212">&#9670;&nbsp;</a></span>ReadDisplayState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ReadDisplayState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the display state. </p>
<p>On success, the result is notified later with <a class="el" href="classCaretaker_1_1DeviceObserver.html#a1e08d70c4dbac488ae3eae13445c7bcd" title="Notification sent to report Device::ReadDisplayState() transaction result. ">DeviceObserver::OnReadDisplayState()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a3c47f157bff768ef4729016fa0d13b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c47f157bff768ef4729016fa0d13b4c">&#9670;&nbsp;</a></span>Recalibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::Recalibrate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalibrate blood pressure measurements. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a15415878a04e3a2b14b797ef5534eeec" title="Writes the calibration interval. ">WriteRecalibrationInterval</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a248e452d39ef934369b2e7d116c36a0b" title="Reads the calibration interval. ">ReadRecalibrationInterval</a> </dd></dl>

</div>
</div>
<a id="a15415878a04e3a2b14b797ef5534eeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15415878a04e3a2b14b797ef5534eeec">&#9670;&nbsp;</a></span>WriteRecalibrationInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::WriteRecalibrationInterval </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the calibration interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>The recalibration interval in minutes. Acceptable range [10, 1440].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a3c47f157bff768ef4729016fa0d13b4c" title="Recalibrate blood pressure measurements. ">Recalibrate</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a248e452d39ef934369b2e7d116c36a0b" title="Reads the calibration interval. ">ReadRecalibrationInterval</a> </dd></dl>

</div>
</div>
<a id="a248e452d39ef934369b2e7d116c36a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248e452d39ef934369b2e7d116c36a0b">&#9670;&nbsp;</a></span>ReadRecalibrationInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ReadRecalibrationInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the calibration interval. </p>
<p>On success, the result is notified later with <a class="el" href="classCaretaker_1_1DeviceObserver.html#af18a587d87ec6982f5ef6c24124d028c" title="Notification sent to report Device::OnReadRecalibrationInterval() transaction result. ">DeviceObserver::OnReadRecalibrationInterval()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a3c47f157bff768ef4729016fa0d13b4c" title="Recalibrate blood pressure measurements. ">Recalibrate</a> </dd>
<dd>
<a class="el" href="classCaretaker_1_1Device.html#a15415878a04e3a2b14b797ef5534eeec" title="Writes the calibration interval. ">WriteRecalibrationInterval</a> </dd></dl>

</div>
</div>
<a id="a587924d99d5e6daca01dca7afb269a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587924d99d5e6daca01dca7afb269a8d">&#9670;&nbsp;</a></span>WriteWaveformClampSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::WriteWaveformClampSetting </td>
          <td>(</td>
          <td class="paramtype">Byte&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the setting to enable or disable clamping the waveforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Clamp setting: 0 = OFF, 1 = ON.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#abea60a6bb86f38f6ae20e86a0ad43868" title="Read the waveform clamping setting. ">ReadWaveformClampSetting</a> </dd></dl>

</div>
</div>
<a id="abea60a6bb86f38f6ae20e86a0ad43868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea60a6bb86f38f6ae20e86a0ad43868">&#9670;&nbsp;</a></span>ReadWaveformClampSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ReadWaveformClampSetting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the waveform clamping setting. </p>
<p>On success, the result is notified later with <a class="el" href="classCaretaker_1_1DeviceObserver.html#ac93191ae3d09de85a63a3e7a9caea50e" title="Notification sent to report Device::ReadWaveformClampSetting() transaction result. ">DeviceObserver::OnReadWaveformClampSetting()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a587924d99d5e6daca01dca7afb269a8d" title="Writes the setting to enable or disable clamping the waveforms. ">WriteWaveformClampSetting</a> </dd></dl>

</div>
</div>
<a id="a728b54de5fcc10ed7d0176bb5a1dc91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728b54de5fcc10ed7d0176bb5a1dc91a">&#9670;&nbsp;</a></span>WriteVitalsFilterSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::WriteVitalsFilterSetting </td>
          <td>(</td>
          <td class="paramtype">Byte&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the filter settings to enable or disable filtering outlier vitals measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Filter setting: 0 = OFF, 1 = ON.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ReadVitalsFiltersSettings </dd></dl>

</div>
</div>
<a id="a076c23dabc4734c6dcd6808d1f93fb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076c23dabc4734c6dcd6808d1f93fb26">&#9670;&nbsp;</a></span>ReadVitalsFilterSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ReadVitalsFilterSetting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current filter settings to enable or disable filtering outlier vitals measurements. </p>
<p>On success, the result is notified later with <a class="el" href="classCaretaker_1_1DeviceObserver.html#aaf6ddf3ea0afa04648aed0f830223ebd" title="Notification sent to report Device::ReadVitalsFilterSetting() transaction result. ...">DeviceObserver::OnReadVitalsFilterSetting()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCaretaker_1_1Device.html#a728b54de5fcc10ed7d0176bb5a1dc91a" title="Writes the filter settings to enable or disable filtering outlier vitals measurements. ">WriteVitalsFilterSetting</a> </dd></dl>

</div>
</div>
<a id="a435ff3459b62f053dc9f56eb48a39b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435ff3459b62f053dc9f56eb48a39b5a">&#9670;&nbsp;</a></span>ReadPersistentLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ReadPersistentLog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the device logs. </p>
<p>On success, the result is notified later with <a class="el" href="classCaretaker_1_1DeviceObserver.html#aed71ea9159c9d2d6721298ef999a9cbf" title="Notification sent to report Device::ReadPersistentTolerance() transaction result. ...">DeviceObserver::OnReadPersistentLog()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Reading the device log is a slow request so the results will be delayed by many seconds.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a797e2d5f66fb1b978cd779ea14286829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797e2d5f66fb1b978cd779ea14286829">&#9670;&nbsp;</a></span>SetLibraryLogLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Caretaker::Device::SetLibraryLogLevel </td>
          <td>(</td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the library log level. </p>
<dl class="section note"><dt>Note</dt><dd>Library logs are written to standard out by default, which maybe the console for console applications. Use <a class="el" href="classCaretaker_1_1Device.html#a6cd9baaa21c213cb11b3fcea0a501f29" title="Redirects library logging to plain-text file libcaretaker.log ">RedirectLibraryLogs()</a> to redirect library logs to a file.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>One of the following log levels. <ul>
<li>
0 - shows all logs, most verbose </li>
<li>
1 - shows only info, warning, and error logs </li>
<li>
2 - shows only warning and error logs </li>
<li>
3 - shows only error logs, least verbose </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17083e351571c629e7771c731154cd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17083e351571c629e7771c731154cd44">&#9670;&nbsp;</a></span>EnableSimulationMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::EnableSimulationMode </td>
          <td>(</td>
          <td class="paramtype">Boolean&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the device simulation mode. </p>
<dl class="section note"><dt>Note</dt><dd>The device does not provide real-time data when simulation mode is enabled. Hard-coded numeric and waveform data (i.e., synthetic data) is provided. As such, simulation mode should be enabled for demonstration and test purposes only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Simulation mode: 1 = Enable, 0 = Disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<a id="a7d32d8f6c3165bac72c0b639be967eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d32d8f6c3165bac72c0b639be967eff">&#9670;&nbsp;</a></span>ClearStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Boolean Caretaker::Device::ClearStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the device status. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the request to the device was initiated and false otherwise. The application must only call this method after the connection is established with the device, i.e., after calling one of the connect methods and connection status CONNECTED is notified. Otherwise, the method returns false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CaretakerDevice_8h_source.html">CaretakerDevice.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 11 2018 10:47:19 for Caretaker Library API 1.6.5 Reference Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
